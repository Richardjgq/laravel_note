# HTTP中间件

### 知识点整理

```
1.简介
    过滤进入应用的 HTTP 请求,认证,保护,跨域等
2.定义中间件
    php artisan make:middleware CheckAge
    以$next($request)为准表示请求之前或之后执行任务
3.注册中间件
    全局中间件:$middleware数组
    $routeMiddleware路由中间件,在路由中使用middleware('auth'),还可以传递完整的类
    把路由中间件组成组$middlewareGroups
    RouteServiceProvider 自动将中间件组 web 应用到 routes/web.php 文件
4.中间件参数
    middleware('role:editor');# 其中role是中间件名,editor是中间件参数,多个参数可以逗号分隔
5.终止中间件
    在 HTTP 响应发送到浏览器之后做一些工作.
```

HTTP中间件为过滤进入应用的HTTP请求提供了一套便利的机制.例如,Laravel内置了一个中间件来验证用户是否经过授权,如果用户没有经过授权,中间件会将用户重定向到登录页面,否则如果用户经过授权,中间件就会允许请求继续往前进入下一步操作.

当然,除了认证之外,中间件还可以被用来处理更多其它任务.比如:CORS中间件可以用于为离开站点的响应添加合适的头\(跨域\);日志中间件可以记录所有进入站点的请求.

Laravel框架自带了一些中间件,包括维护模式、认证、CSRF 保护中间件等等.所有的中间件都位于`app/Http/Middleware` 目录.

### 定义中间件

要创建一个新的中间件,可以通过Artisan命令`make:middleware`:

```
php artisan make:middleware CheckAge
```

这个命令会在`app/Http/Middleware`目录下创建一个新的中间件类CheckAge,在这个中间件中,只允许提供的age大于200的请求访问路由,否则将用户重定向到home:

```
<?php
namespace App\Http\Middleware;
use Closure;
class CheckAge
{
    // 返回请求过滤器
    public function handle($request, Closure $next)
    {
        if ($request->input('age') <= 100) {
            return redirect('home');
        }
        return $next($request);
    }
}
```

理解中间件的最好方式就是将中间件看做HTTP请求到达目标动作之前必须经过的"层",每一层都会检查请求并且可以完全决绝它.

**中间件之前\/之后**

一个中间件是请求前还是请求后执行取决于中间件本身.

以下中间件会在请求处理前执行一些任务:

```
<?php
namespace App\Http\Middleware;
use Closure;
class BeforeMiddleware
{
    public function handle($request, Closure $next)
    {
        // 执行动作
        return $next($request);
    }
}
```

在请求处理后执行其任务:

```
<?php
namespace App\Http\Middleware;
use Closure;
class AfterMiddleware
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);
        // 执行动作
        return $response;
    }
}
```

### 注册中间件

**全局中间件**

如果想要中间件在每一个HTTP请求期间被执行,只需要将相应的中间件类设置到`app/Http/Kernel.php`的数组属性`$middleware`中即可.

**分配中间件到路由**

如果想要分配中间件到指定路由,首先应该在`app/Http/Kernel.php`文件中分配给该中间件一个简写的key.默认情况下,该类的$routeMiddleware属性包含了Laravel内置的入口中间件,添加自己的中间件,只需要将其追加到后面并为其分配一个key,例如:

```php
// Within App\Http\Kernel Class...
protected $routeMiddleware = [
    'auth' => \Illuminate\Auth\Middleware\Authenticate::class,
    'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
    'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
    'can' => \Illuminate\Auth\Middleware\Authorize::class,
    'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
];
```

中间件在HTTP Kernel中被定义后,可以使用middleware方法将其分配到路由:

```php
Route::get('admin/profile', function () {
    // 
})->middleware('auth');
```

使用数组分配多个中间件到路由:

```
Route::get('/', function () {
    //
})->middleware('first', 'second');
```

分配中间件的时候还可以传递完整的类名:

```
use App\Http\Middleware\CheckAge;
Route::get('admin/profile', function () {
    //
})->middleware(CheckAge::class);
```

**中间件组**

要通过指定一个键名的方式将相关中间件分到同一个组里面,从而更方便将其分配到路由中,这可以通过使用HTTP Kernel的$middlewareGroups属性实现.

Laravel自带了开箱即用的web和api两个中间件组以包含可以应用到WebUI和API路由的通用中间件:

```
protected $middlewareGroups = [
    'web' => [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],
    'api' => [
        'throttle:60,1',
        'auth:api',
    ],
];
```

中间件组可以被分配给路由和控制器动作,使用和单个中间件分配同样的语法.再次申明,中间件组的目的只是让一次分配给路由多个中间件的实现更加简单:

```
Route::get('/', function () {
    //
})->middleware('web');

Route::group(['middleware' => ['web']], function () {
    //
});
```

> 注:默认情况下,RouteServiceProvider自动将中间件组web应用到routes\/web.php文件.

### 中间件参数

中间件还可以接收额外的自定义参数.例如,如果应用需要在执行给定动作之前验证认证用户是否拥有指定的角色,可以创建一个CheckRole来接收角色名作为额外参数.

额外的中间件参数会在`$next`参数之后传入中间件:

```php
<?php
namespace App\Http\Middleware;
use Closure;
class CheckRole
{
    // 运行请求过滤器
    public function handle($request, Closure $next, $role)
    {
        if (! $request->user()->hasRole($role)) {
            // Redirect...
        }
        return $next($request);
    }
}
```

中间件参数可以在定义路由时通过:分隔中间件名和参数名来指定,多个中间件参数可以通过逗号分隔:

```
Route::put('post/{id}', function ($id) {
    //
})->middleware('role:editor');
```

### 可终止的中间件

有时候中间件可能需要在HTTP响应发送到浏览器之后做一些工作.比如,Laravel内置的"session"中间件会在响应发送到浏览器之后将Session数据写到存储器中,为了实现这个功能,需要定义一个可终止的中间件并添加`terminate`方法到这个中间件:

```
<?php
namespace Illuminate\Session\Middleware;
use Closure;
class StartSession
{
    public function handle($request, Closure $next)
    {
        return $next($request);
    }
    public function terminate($request, $response)
    {
        // 存储session数据...
    }
}
```

`terminate` 方法将会接收请求和响应作为参数.定义了一个可终止的中间件之后,还需要将其加入到 HTTP kernel 的全局中间件列表中.

当调用中间件上的 `terminate` 方法时,Laravel 将会从服务容器中取出该中间件的新的实例,如果你想要在调用`handle` 和 `terminate` 方法时使用同一个中间件实例,则需要使用容器的 `singleton` 方法将该中间件注册到容器中.

