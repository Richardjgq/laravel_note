# HTTP中间件

HTTP中间件为过滤进入应用的HTTP请求提供了一套便利的机制.例如,Laravel内置了一个中间件来验证用户是否经过授权,如果用户没有经过授权,中间件会将用户重定向到登录页面,否则如果用户经过授权,中间件就会允许请求继续往前进入下一步操作.

当然,除了认证之外,中间件还可以被用来处理更多其它任务.比如:CORS中间件可以用于为离开站点的响应添加合适的头\(跨域\);日志中间件可以记录所有进入站点的请求.

Laravel框架自带了一些中间件,包括维护模式、认证、CSRF 保护中间件等等.所有的中间件都位于`app/Http/Middleware` 目录.

### 定义中间件

要创建一个新的中间件,可以通过Artisan命令`make:middleware`:

```
php artisan make:middleware CheckAge
```

这个命令会在`app/Http/Middleware`目录下创建一个新的中间件类CheckAge,在这个中间件中,只允许提供的age大于200的请求访问路由,否则将用户重定向到home:

```
<?php
namespace App\Http\Middleware;
use Closure;
class CheckAge
{
    // 返回请求过滤器
    public function handle($request, Closure $next)
    {
        if ($request->input('age') <= 100) {
            return redirect('home');
        }
        return $next($request);
    }
}
```

理解中间件的最好方式就是将中间件看做HTTP请求到达目标动作之前必须经过的"层",每一层都会检查请求并且可以完全决绝它.

**中间件之前\/之后**

一个中间件是请求前还是请求后执行取决于中间件本身.

以下中间件会在请求处理前执行一些任务:

```
<?php
namespace App\Http\Middleware;
use Closure;
class BeforeMiddleware
{
    public function handle($request, Closure $next)
    {
        // 执行动作
        return $next($request);
    }
}
```

在请求处理后执行其任务:

```
<?php
namespace App\Http\Middleware;
use Closure;
class AfterMiddleware
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);
        // 执行动作
        return $response;
    }
}
```

### 注册中间件

**全局中间件**

如果想要中间件在每一个HTTP请求期间被执行,只需要将相应的中间件类设置到`app/Http/Kernel.php`的数组属性`$middleware`中即可.

**分配中间件到路由**

如果想要分配中间件到指定路由,首先应该在`app/Http/Kernel.php`文件中分配给该中间件一个简写的key.默认情况下,该类的$routeMiddleware属性包含了Laravel内置的入口中间件,添加自己的中间件,只需要将其追加到后面并为其分配一个key,例如:

```php
// Within App\Http\Kernel Class...
protected $routeMiddleware = [
    'auth' => \Illuminate\Auth\Middleware\Authenticate::class,
    'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
    'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
    'can' => \Illuminate\Auth\Middleware\Authorize::class,
    'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
];
```

中间件在HTTP Kernel中被定义后,可以使用middleware方法将其分配到路由:

```php
Route::get('admin/profile', function () {
    // 
})->middleware('auth');
```

使用数组分配多个中间件到路由:

```
Route::get('/', function () {
    //
})->middleware('first', 'second');
```

分配中间件的时候还可以传递完整的类名:

```
use App\Http\Middleware\CheckAge;
Route::get('admin/profile', function () {
    //
})->middleware(CheckAge::class);
```

**中间件组**

要通过指定一个键名的方式将相关中间件分到同一个组里面,从而更方便将其分配到路由中,这可以通过使用HTTP Kernel的$middlewareGroups属性实现.

Laravel自带了开箱即用的web和api两个中间件组以包含可以应用到WebUI和API路由的通用中间件:

```
protected $middlewareGroups = [
    'web' => [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],
    'api' => [
        'throttle:60,1',
        'auth:api',
    ],
];
```

中间件组可以被分配给路由和控制器动作,使用和单个中间件分配同样的语法.再次申明,中间件组的目的只是让一次分配给路由多个中间件的实现更加简单:

```
Route::get('/', function () {
    //
})->middleware('web');

Route::group(['middleware' => ['web']], function () {
    //
});
```



### 中间件参数

### 可终止的中间件

