# 服务容器

## 简介

服务容器是一个用于管理类依赖和执行依赖注入的强大工具.依赖注入听上去很花哨,其实质是通过构造函数或者某些情况下通过set方法将类依赖注入到类中.

例如:

```php
<?php
namespace App\Http\Controllers;

use App\User;
use App\Repositories\UserRepository;
use App\Http\Controllers\Controller;

class UserController extends Controller
{
    protected $users;

    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    public function show($id)
    {
        $user = $this->users->find($id);
        return view('user.profile', ['user' => $user]);
    }
}
```

分析:在这个例子中,UserController需要从数据源获取用户.所以,注入了一个可以获取用户的服务UserRepository,其扮演的角色类似使用Eloquent从数据库获取用户信息.注入后,就可以在其基础上封装其他实现,也可以模拟或者创建一个假的UserRepository实现用于测试.

## 绑定

### **绑定基础**

几乎所有的服务容器绑定都是在服务提供者中完成.下面的例子用到的容器都是在服务提供者中绑定的.

> 注:如果一个类没有基于任何接口,那么就没有必要将其绑定到容器.容器并不需要被告知如何构建对象,因为它会使用PHP的反射服务自动解析出具体的对象.

**简单的绑定**

在一个服务提供者中,可以通过`$this->app`变量访问容器,然后使用bind方法注册一个绑定,该方法需要两个参数,第一个参数是我们想要注册的类名或接口名,第二个参数是返回类的实例的闭包:

```php
$this->app->bind('HelpSpot\API', function ($app) {
    return new HelpSpot\API($app->make('HttpClient'));
});
```

将容器本身作为解析器的一个参数,然后可以使用该容器来解析正在构建的对象的子依赖.

**绑定一个单利**

singleton方法绑定一个只需要解析一次的类或接口到容器,然后对容器的调用将会返回同一个实例:

```php
$this->app->singleton('FooBar', function ($app) {
    return new FooBar($app->make('HttpClient'));
});
```

**绑定实例**

还可以直接使用instance方法绑定一个已存在的对象实例到容器,随后调用容器将总是返回给定的实例:

```php
$api = new HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\Api', $api);
```

**绑定原始值**

有一个接收注入类的类,同时需要注入一个原生的数值比如整数,可以结合上下文注入这个类需要的任何值:

```
$this->app->when('App\Http\Controllers\UserController')
    ->needs('$variableName')
    ->give($value);
```

### **绑定接口到实现**

服务容器的一个非常强大的功能是其绑定接口到实现.假设有一个EventPusher接口及其实现类RedisEventPusher,编写完该接口的RedisEventPusher实现后,就可以将其注册到服务容器:

```php
$this->app->bind(
    'App\Contracts\EventPusher',
    'App\Services\RedisEventPusher'
);
```

这段代码告诉容器,当一个类需要EventPusher的实现时将会注入RedisEventPusher,现在可以在构造器或者任何其他通过服务容器注入依赖的地方进行EventPusher接口的依赖注入:

```php
use App\Contracts\EventPusher;
public function __construct(EventPusher $pusher)
{
    $this->pusher = $pusher;
}
```

### **上下文绑定**

两个类使用同一个接口,在每个类中注入不同实现.例如,两个控制器依赖`Illuminate\Contracts\Filesystem\Filesystem` 接口的不同实现.Laravel为此定义了简单,平滑的接口:

```php
use Illuminate\Support\Facades\Storage;
use App\Http\Controllers\VideoController;
use App\Http\Controllers\PhotoControllers;
use Illuminate\Contracts\Filesystem\Filesystem;

$this-app->when(PhotoController::class)
    ->needs(Filesystem::class)
    ->give(function(){
        return Storage::disk('local');
    });
$this->app->when(VideoController::class)
    ->needs(Filesystem::class)
    ->give(function(){
        return Storage::disk('s3');
    });
```

### **标签**

少数情况下,需要解析特定分类下的所有绑定.例如,正在构建一个接收多个不同Report接口实现的报告聚合器,在注册完Report实现之后,可以通过tag方法给他们分配一个标签:

```php
$this->app->bind('SpeedReport', function(){
    //
});
$this->app->bind('MemoryReport', function(){
    //
});
$this->app->tag(['SpeedReport','MemoryReport'],'reports');
```

这些服务被打上标签后,可以通过tagged方法来轻松解析它们:

```
$this->app->bind('ReportAggregator', function($app){
    return new ReportAggregator($app->tagged('reports'));
});
```

## 解析

### make方法

很多方式可以从容器中解析对象,可以使用make方法,接收你想要解析的类名或接口名作为参数:

```php
$fooBar = $this->app->make('HelpSpot\API');
```

如果所在的代码位置访问不了$app变量,可以使用辅助函数:

```php
$api = app('HelpSpot\API');
```

### 自动注入

最常用的可以简单的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象,控制器,事件监听器,队列任务,中间件等等都是通过这种方式.在实践中,这也是大多数对象从容器中解析的方式.

容器会自动为其解析类注入依赖.例如,可以在控制器的构造函数中为应用定义的仓库进行类型提示,该仓库会自动解析并注入该类:

```php
<?php
namespace App\Http\Controllers;

use Illuminate\Routing\Controller;
use App\Users\Repository as UserRepository;

class UserController extends Controller
{
    // 用户仓库实例
    protected $users;

    // 创建一个控制器实例
    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    public function show($id)
    {
        //
    }
}
```

## 容器事件

服务容器在每一次解析对象时都会触发一个事件,可以使用resolving方法监听该事件:

```
$this->app->resolving(function ($object, $app) {
    //
});
$this->app->resolving(HelpSpot\API::class, function ($api, $app) {
    //
});
```

被解析的对象将会传递给回调函数,从而允许在对象被传递给消费者之前为其设置额外属性.

