# 服务容器

## 简介

服务容器是一个用于管理类依赖和执行依赖注入的强大工具.依赖注入听上去很花哨,其实质是通过构造函数或者某些情况下通过set方法将类依赖注入到类中.

例如:

```php
<?php
namespace App\Http\Controllers;

use App\User;
use App\Repositories\UserRepository;
use App\Http\Controllers\Controller;

class UserController extends Controller
{
    protected $users;

    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    public function show($id)
    {
        $user = $this->users->find($id);
        return view('user.profile', ['user' => $user]);
    }
}
```

分析:在这个例子中,UserController需要从数据源获取用户.所以,注入了一个可以获取用户的服务UserRepository,其扮演的角色类似使用Eloquent从数据库获取用户信息.注入后,就可以在其基础上封装其他实现,也可以模拟或者创建一个假的UserRepository实现用于测试.

## 绑定

### **绑定基础**

几乎所有的服务容器绑定都是在服务提供者中完成.下面的例子用到的容器都是在服务提供者中绑定的.

> 注:如果一个类没有基于任何接口,那么就没有必要将其绑定到容器.容器并不需要被告知如何构建对象,因为它会使用PHP的反射服务自动解析出具体的对象.

**简单的绑定**

在一个服务提供者中,可以通过`$this->app`变量访问容器,然后使用bind方法注册一个绑定,该方法需要两个参数,第一个参数是我们想要注册的类名或接口名,第二个参数是返回类的实例的闭包:

```php
$this->app->bind('HelpSpot\API', function ($app) {
    return new HelpSpot\API($app->make('HttpClient'));
});
```

将容器本身作为解析器的一个参数,然后可以使用该容器来解析正在构建的对象的子依赖.

**绑定一个单利**

singleton方法绑定一个只需要解析一次的类或接口到容器,然后对容器的调用将会返回同一个实例:

```php
$this->app->singleton('FooBar', function ($app) {
    return new FooBar($app->make('HttpClient'));
});
```

**绑定实例**

还可以直接使用instance方法绑定一个已存在的对象实例到容器,随后调用容器将总是返回给定的实例:

```php
$api = new HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\Api', $api);
```

**绑定原始值**

有一个接收注入类的类,同时需要注入一个原生的数值比如整数,可以结合上下文注入这个类需要的任何值:

```
$this->app->when('App\Http\Controllers\UserController')
    ->needs('$variableName')
    ->give($value);
```

### **绑定接口到实现**

服务容器的一个非常强大的功能是其绑定接口到实现.假设有一个EventPusher接口及其实现类RedisEventPusher,编写完该接口的RedisEventPusher实现后,就可以将其注册到服务容器:

```php
$this->app->bind(
    'App\Contracts\EventPusher',
    'App\Services\RedisEventPusher'
);
```

这段代码告诉容器,当一个类需要EventPusher的实现时将会注入RedisEventPusher,现在可以在构造器或者任何其他通过服务容器注入依赖的地方进行EventPusher接口的依赖注入:

```php
use App\Contracts\EventPusher;
public function __construct(EventPusher $pusher)
{
    $this->pusher = $pusher;
}
```

### **上下文绑定**

两个类使用同一个接口,在每个类中注入不同实现.例如,两个控制器依赖`Illuminate\Contracts\Filesystem\Filesystem` 接口的不同实现.Laravel为此定义了简单,平滑的接口:

```
use Illuminate\Support\Facades\Storage;
use App\Http\Controllers\VideoController;
use App\Http\Controllers\PhotoControllers;
use Illuminate\Contracts\Filesystem\Filesystem;

$this-app->when(PhotoController::class)
    ->needs(Filesystem::class)
    ->give(function(){
        return Storage::disk('local');
    });
$this->app->when(VideoController::class)
    ->needs(Filesystem::class)
    ->give(function(){
        return Storage::disk('s3');
    });
```

### **标签**

少数情况下,需要解析特定分类下的所有绑定.例如,正在构建一个接收多个不同Report接口实现的报告聚合器,在注册完Report实现之后,可以通过tag方法给他们分配一个标签:



## 解析

## 容器事件

