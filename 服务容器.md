# 服务容器

## 简介

服务容器是一个用于管理类依赖和执行依赖注入的强大工具.依赖注入听上去很花哨,其实质是通过构造函数或者某些情况下通过set方法将类依赖注入到类中.

例如:

```php
<?php
namespace App\Http\Controllers;

use App\User;
use App\Repositories\UserRepository;
use App\Http\Controllers\Controller;

class UserController extends Controller
{
    protected $users;

    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    public function show($id)
    {
        $user = $this->users->find($id);
        return view('user.profile', ['user' => $user]);
    }
}
```

分析:在这个例子中,UserController需要从数据源获取用户.所以,注入了一个可以获取用户的服务UserRepository,其扮演的角色类似使用Eloquent从数据库获取用户信息.注入后,就可以在其基础上封装其他实现,也可以模拟或者创建一个假的UserRepository实现用于测试.

## 绑定

### **绑定基础**

几乎所有的服务容器绑定都是在服务提供者中完成.下面的例子用到的容器都是在服务提供者中绑定的.

> 注:如果一个类没有基于任何接口,那么就没有必要将其绑定到容器.容器并不需要被告知如何构建对象,因为它会使用PHP的反射服务自动解析出具体的对象.

**简单的绑定**

在一个服务提供者中,可以通过`$this->app`变量访问容器,然后使用bind方法注册一个绑定,该方法需要两个参数,第一个参数是我们想要注册的类名或接口名,第二个参数是返回类的实例的闭包:

```php
$this->app->bind('HelpSpot\API', function ($app) {
    return new HelpSpot\API($app->make('HttpClient'));
});
```

将容器本身作为解析器的一个参数,然后可以使用该容器来解析正在构建的对象的子依赖.

**绑定一个单利**

singleton方法绑定一个只需要解析一次的类或接口到容器,然后对容器的调用将会返回同一个实例:

```
$this->app->singleton('FooBar', function ($app) {
    return new FooBar($app->make('HttpClient'));
});
```

### **绑定接口到实现**

### **上下文绑定**

### **标签**

## 解析

## 容器事件

