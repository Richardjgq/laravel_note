# 起步

### 基础介绍

Laravel自带的Eloquent ORM提供了一个美观、简单的与数据库打交道的ActiveRecord实现,每张数据表都对应一个与该表进行交互的“模型”,模型允许你在表中进行数据查询,以及插入、更新、删除等操作.

> 开始之前确保在`config/database.php`文件中配置好了数据库连接.

这里有几个基本概念:

Eloquent是Laravel的ORM的名字,"ORM"即"Object Relational Mapping",对象关系映射.

**ActiveRecord**

ActiveRecord是什么

1. 每一个数据库表对应创建一个类.类的每一个对象实例对应于数据库中表的一行记录.通常表的每个字段在类中都有相应的Field.
2. ActiveRecord同时负责把自己持久化.在ActiveRecord中封装了对数据库的访问,例如基本的CURD.
3. ActiveRecord是一种领域模型\(Domain Model\),封装了部分业务逻辑.

ActiveRecord不是什么
1. Row Data Gateway

* Row Data Gateway模式中每个对象也封装了数据库记录的状态和持久化到数据库的访问方法;
* 这两个有时候很难区分. 细微的区别在于Row Data Gateway不封装任何业务逻辑;

* TableGateway

  * TableGateway是一种数据访问模式,对每个表有一个类,类的方法封装了对单个表的数据操作,如CRUD;
  * 方法的接受表字段的值作为参数;
  * 它和ActiceRecord的区别在于,ActiveRecord的对象中保持了记录值,是有状体的,而TableGateway是没有状态的,只是一系列数据库访问方法的集合;

* Table Module

  * Table Module是一种领域逻辑模式,一个类对应于数据库中的一个表;
  * Table Module通常和Table Gateway合作,前者负责基本的业务逻辑,后者负责数据库访问,以达到逻辑层和持久化层的隔离
  * 例如对表Person,通常会定义两个类,PersonBL和PersonDB,在PersonBL中处理验证等逻辑,并调用PersonDB访问数据库,层间调用使用DataSet或自定义数据传输对象传输数据


> 在业务逻辑比较简单并且有和表一一对应时,ActiveRecord相对来说更简单,因为它在一个类中包括了业务逻辑对象和数据访问,而且不需要数据传输对象,减少了维护的工作量.和Table Module比较起来,ActiveRecord与数据库耦合的更紧.

ActiceRecord适用于:

1. 业务逻辑比较简单.当你的类基本上和数据库中的表一一对应时,ActiveRecord是非常方便的,即你的业务逻辑大多数是对单表操作.
2. 当发生跨表操作时,往往会配合使用事务脚本\(Transaction Script\),把跨表事务提升到事务脚本中.
3. ActiceRecord最大的优点就是简单直观.一个类就包含了数据访问和业务逻辑.如果配合代码生成器使用就更方便了.
4. 上面这些优点使ActiveRecord特别适合Web快速开发.

ActiveRecord不适用于:
1. ActiveRecord虽然有业务逻辑,但基本上都是基于表单的.跨表逻辑一般会放到当发生跨表的操作时, 往往会配合使用事务脚本\(Transaction Script\)中.如果对象间的关联越来越多,那么事务脚本会越来越大,重复的代码越来越多,这时就要考虑Domain Model+O\/R mapping了.
2. ActiveRecord保存了数据,使它有时候看上去像数据传输对象\(DTO\).但是ActiveRecord有数据库访问能力,不要把它当DTO用.尤其在跨越进程边界调用的时候,不能传递ActiveRecord对象

**Eloquent ORM所完成的就是上文中描述的Domain+O\/R mapping.**

上文中ActiveRecord相关内容来自:

* http:\/\/houzhe11.iteye.com\/blog\/494296

* http:\/\/www.cnblogs.com\/yonge\/archive\/2011\/11\/20\/2256452.html


### 定义模型

创建Eloquent模型通常位于app目录下或者能被composer.json自动加载到的地方,并继承`Illuminate\Database\Eloquent\Model`类.

创建模型最简单的方法还是使用Artisan命令make:model

```
php artisan make:model User
```

如果想要在生成模型时生成数据库迁移,可以使用--migration或-m选项

```
php artisan make:model --migration
php artisan make:model -m
```

**Eloquent模型约定**

创建一个Flight模型类例子,用这个类获取和存储数据表flights中的信息:

```
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Flight extends Modle
{
    //
}
```

**表名**

默认规则是模型类名的复数作为与其对应的表名,除非在模型类中明确指定了其他名称.可以在模型类中定义table属性来自定义表名

```
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    // 关联到模型的数据表
    protected $table = 'my_flights';
}
```

**主键**

Eloquent默认每张表的主键为id,可以在模型中定义一个$primaryKey属性来覆盖该约定

**时间戳**

默认情况下,Eloquent期望created\_at和update\_at已经存在于数据表中,如果不想要这些Laravel自动管理的列,在模型中设置$timestamps属性为false

```
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Fligth extends Model
{
    // 表示模型是否应该被打上时间戳
    public $timestamps = false;
}
```

如果需要自定义时间戳格式,设置模型中的$dateFormat属性.该属性决定日期被如何存储到数据库中,以及模型被序列化为数组或JSON时日期的格式:

```
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Fligth extends Model
{
    // 模型日期列的存储格式,U表示时间戳
    protected $dateFormat = 'U';
}
```

**数据库连接**

默认情况下,所有的Eloquent模型使用应用配置中的默认数据库连接,如果想要为模型指定不同的连接,可以通过$connection属性来设置

```
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Fligth extends Model
{
    // The connection name for the model
    // 在config中的database文件的connetions数组
    protected $connection = 'connection-name';
}
```

### 获取多个模型

创建完模型及其关联的数据表后,从数据库中获取数据,可以把模型当成查询构建器,使用它来查询与其关联的数据表.

```
<?php
namespace App\Http\Controllers;

use App\Fligth;
use App\Http\Controllers\Controller;

class FligthController extends Controller
{
    // 显示所有航班列表
    public function index()
    {
        $fligths = Fligth::all();
        return view('fligth.index', ['fligths' => $fligths]);
    }
}
```

**访问列值**

有一个模型实例,可以通过访问其相应的属性来访问模型的列值.例如,循环查询返回的每一个Flight实例并输出name的值

```
<?php
namespace App\Http\Controllers;

use App\Flight;
use App\Http\Controllers\Controller;

class FlightController extends Controller
{
    // 循环查询返回的每一个Flight实例并输出name的值
    public function index()
    {
        $flights = Flight:all();
        foreach ($flights as $flight) {
            echo $flight->name;
        }
    }
}
```



